\documentclass[12pt, a4paper, oneside, openright]{article}
\usepackage[dvips, bottom=15mm, top=15mm, right=4cm, left=2cm, bindingoffset=5mm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\clubpenalty=10000
\widowpenalty=10000
\displaywidowpenalty=10000
\usepackage[babel, german=quotes]{csquotes}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{amsmath}
\usepackage[tbtags]{mathtools}
\usepackage{pgfplots}
\usepackage{enumerate}
\usepackage{enumitem}
\usepackage{xspace}
\usepackage{graphicx}
\usepackage{pdfpages}
\usepackage{framed}
\usepackage{mdframed}
\usepackage{relsize}
\usepackage{float}
\usepackage{longtable}
\usepackage[bottom, perpage, para]{footmisc}
\usepackage{lipsum}
\usepackage{blindtext}
\usepackage{calligra}
\usepackage[hyphenbreaks]{breakurl}
\usepackage{xurl}
\usepackage{microtype}
\usepackage{verbatim}
\usepackage[font={scriptsize}, labelfont=bf, format=hang]{caption}
\usepackage[font={scriptsize}, labelfont=bf, labelformat=simple]{subcaption}
% FIX: Allow more than 26 subfigures
\renewcommand{\thesubfigure}{\,(\arabic{subfigure})}
\usepackage[linesnumbered, commentsnumbered, boxed, german]{algorithm2e}
\renewcommand{\listalgorithmcfname}{Algorithmenverzeichnis}
\usepackage{listings}
\renewcommand{\lstlistingname}{Quelltext} 
\renewcommand{\lstlistlistingname}{Quelltextverzeichnis}



% Hyperref-Setup (Verweise sind verlinkt, sodass an die korrekte Stelle gesprungen wird)
\usepackage{hyperref}
\hypersetup{
    colorlinks,
    pdfpagelabels,
    pdfstartview = FitH,
    bookmarksopen = true,
    bookmarksnumbered = true,
    linkcolor = black,
    plainpages = false,
    hypertexnames = false,
    citecolor = black,
}
\usepackage{setspace}
\setstretch{1.5}
\pdfcompresslevel=0
\pdfobjcompresslevel=0
\pdfimageresolution=4000



% Abkürzungen
\newcommand \ggfs{ggfs.\xspace }
\newcommand \zB{z.\,B.\xspace }
\newcommand \sieheoben{s.\,o.\xspace }
\newcommand \siehe{s.\xspace }
\newcommand \dasheisst{d.\,h.\xspace }
\newcommand \ua{u.\,a.\xspace }
\newcommand \ia{i.\,a.\xspace }
\newcommand \idR{i.\,d.\,R.\xspace }
\newcommand \bspw{bspw.\xspace }
\newcommand \bzw{bzw.\xspace }
\newcommand \evtl{evtl.\xspace }
\newcommand \bzgl{bzgl.\xspace }
\newcommand \und{u.\xspace }
\newcommand \vgl{vgl.\xspace }
\newcommand \usw{u.\,s.\,w.\xspace }
\newcommand \insbes{insbes.\xspace }
\newcommand \etc{etc.\xspace }
\newcommand \sog{sog.\xspace }
\newcommand \ca{ca.\xspace }
\newcommand \zT{z.\,T.\xspace }
\newcommand \so{s.\,o.\xspace }
\newcommand \etal{et.\,al.\xspace }
\newcommand \ebd{ebd.\xspace }
\newcommand \ebdS{ebd.\,S.\,}
\newcommand \va{v.\,a.\xspace }
\newcommand \vglebd{vgl.\,ebd.\xspace }
\newcommand \vglebdS{vgl.\,ebd.\,S.\,}
\newcommand \Seite{S.\,}
\newcommand \Kap{Kap.\xspace }
\newcommand \Abb{Abb.\xspace }
\newcommand \jew{jew.\xspace }
\newcommand \versch{versch.\xspace }
\newcommand \engl{engl.\xspace }
\newcommand \EF{EF\xspace }
\newcommand \UVH{UVH\xspace }
\newcommand \Abs{Abs.\,}
\newcommand \wahrsch{wahrsch.\xspace }
\newcommand \Zeile{Z.\,}
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{}}}



% Farben (in RGB definiert)
\usepackage{xcolor}
\usepackage{colortbl}
\usepackage{biblatex}
\definecolor{dunkelgrau}{rgb}{0.75,0.75,0.75}
\definecolor{mittelgrau}{rgb}{0.85,0.85,0.85}
\definecolor{hellgrau}{rgb}{0.95,0.95,0.95}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\definecolor{bondiblue}{rgb}{0.0, 0.58, 0.71}
\definecolor{lightblue}{rgb}{0.68, 0.85, 0.9}
\definecolor{lightgreen}{rgb}{0.56, 0.93, 0.56}



% Quelltext-Umgebung fü Java definieren:
\newcommand\javastyle{\lstset{
    language=Java,
    otherkeywords={},
    keywordstyle=\color{deepblue},
    emph={},          
    emphstyle=\color{deepred},
    stringstyle=\color{deepgreen},
    commentstyle=\color{orange},    
    frame=,
    showstringspaces=false,
    showtabs=true,
    tabsize=3,
    tab=,
    showstringspaces=true,
    numbers=left,
    breakatwhitespace=true,
    breakatwhitespace = true,
    breakindent = 2ex,
    extendedchars=true,
    breaklines=true,
    numberstyle=\tiny,
    numbersep=9pt,
    stepnumber=1,
    captionpos=b,
    backgroundcolor=\color{hellgrau}
}}



% Zwei verschiedene Textgrößen definieren

% a) für den Fließtext
\newcommand\javastyleTextgroesseNormal{\lstset{
    basicstyle=\ttfamily\mdseries\color{black}\linespread{0.8}
}}

% b) für längere Zitate
\newcommand\javastyleTextgroesseKlein{\lstset{
    basicstyle=\scriptsize\ttfamily\mdseries\color{black}\linespread{0.8}
}}

% "Java" als neue Umgebung definieren
\lstnewenvironment{java}[1][]{\javastyle\javastyleTextgroesseKlein\lstset{#1}}{}

% Java-Umgebung für externe Dateien definieren
\newcommand\javaexternal[2][]{{\javastyle\javastyleTextgroesseKlein\lstinputlisting[#1]{#2}}}

% Java-Code im Fließtext
\newcommand\javainline[1]{{\javastyle\javastyleTextgroesseNormal\lstinline!#1!}}



% Titel und Autor
% Stichworte beim hyperref-Setup ändern!
\title{Der Algorithmus >>Minimax<< und seine Anwendung auf das Schachspiel}
\author{Paul Fragemann}
\date{Version: \today}

\makeatletter
\hypersetup{
    pdftitle={\@title},
    pdfauthor={\@author},
    pdfsubject={Facharbeit, Quicksort, Liste, Algorithmus, Implementation} % hier Stichworte ändern
}
\makeatother



% ACHTUNG!
% Vor dem Ausdruck auskommentieren
% Das Paket kann helfen, Fehler in Verweisen aufzudecken
% \usepackage{refcheck}

% Das Paket kann helfen, zu lange Zeilen zu entdecken
% \usepackage{showframe}


\setcounter{tocdepth}{4}
\setcounter{secnumdepth}{4}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%                  %%%%%%%
%%%%%%%   ENDE PRÄAMEL   %%%%%%%
%%%%%%%                  %%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





\begin{document}

\maketitle
\thispagestyle{empty}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\textwidth]{assets/Titelbild}
    \caption[Schachbrett vor einem Programm]{Schachbrett vor einem Programm. Eigenes Bild.}
    \label{fig:Titelbild}
\end{figure}

\vfill

\noindent
\begin{tabular}{p{4cm}l}
    Fach:                   & Informatik \tabularnewline
    Kurs:                   & Q1 GK 1 \tabularnewline
    Betreuende Lehrkraft:   & Herr Hendler \tabularnewline
    Themenausgabe:          & 02.02.2024 \tabularnewline
    Abgabe:                 & 21.03.2024 \tabularnewline
\end{tabular}

\newpage

\thispagestyle{empty}
\pdfbookmark[1]{Inhaltsverzeichnis}{Inhaltsverzeichnis} 
\tableofcontents



\newpage
\setcounter{page}{3}
\section{Einleitung}\label{sec:einleitung}
\subsection{Motivation}\label{subsec:motivation}
In einer Zeit, in der Künstliche Intelligenzen wie Chat-GPT\footnote{Offizielle Chat-GPT Website von Open-AI: \url{https://chat.openai.com/} (Abgerufen: 10.03.2024)} und ähnliche Künstliche Intelligenzen, die aus enormen Datensätzen an Trainingsdaten trainiert wurden, in aller Munde sind und einem überall begegnen, lässt sich natürlich die Frage stellen, warum traditionelle Algorithmen, wie \zB der hier besprochene Minimax Algorithms überhaupt noch relevant sind, vor allem wenn maschinelle Lernsysteme anstelle dieser Alogorithmen mit großem Erfolg eingesetzt werden können, wie im Falle des hier besprochenen Schachspiels zum Beispiel AlphaZero\footnote{David Silver \etal (2017): Mastering Chess and Shogi by Self-Play with a General Reinforcement Learning Algorithm \url{https://arxiv.org/abs/1712.01815} (Abgerufen 10.03.2024)}.
Meiner Meinung nach sind diese Algorithmen auch heute immer noch wichtig, da diese im Vergleich zu Künstlichen Intelligenzen vorhersehbarer sind.
Wenn ein solcher Algorithmus einen Fehler hat, lässt sich dieser systematisch suchen und lösen, während es bei Künstlichen Intelligenzen kaum solche Möglichkeiten gibt, außer diese auf einem verändertem Datensatz erneut \bzw weiter zu Trainieren.

\subsection{Warum Schach?}\label{subsec:warum-schach?}
Der hier besprochene Minimax Algorithmus lässt sich nicht nur auf das Schachspiel, sondern auf alle Spiele mit zwei Spielern, bei denen es keinen Zufallsaspekt gibt anwenden\footnote{Neumann, J. von. \enquote{Zur Theorie der Gesellschaftsspiele.} Mathematische Annalen 100 (1928): S. 295--320. \url{https://eudml.org/doc/159291} (Abgerufen 10.03.2024)}.
Da es eine enorm große Menge an solchen Spielen gibt, wie \zB TicTacToe, Dame, Shogi und eben Schach und ich in dieser Arbeit den Algorithmus nicht nur abstrakt untersuchen, sondern auch auf ein praktisches Beispiel eingehen wollte, habe ich mich aus mehreren Gründen für das Schachspiel entschiedenen.
Zum einen ist dieses, anders als \zB TicTacToe, nicht gelöst \dasheisst es wurde noch keine perfekte Strategie gefunden, mit der einer der beiden Spieler einen Sieg \bzw ein Unentschieden erzwingen kann, zum anderen spiele ich persönlich sehr gerne Schach.

\section{Der Minimax Algorithmus}\label{sec:der-minimax-algorithmus}
Der Minimax Algorithmus ist ein rekursiver Algorithmus aus der kombinatorischen Spieltheorie, der bei Spielen mit zwei Spielern, bei denen beide Spieler Zugriff auf alle das Spiel betreffenden Informationen haben, \dasheisst es keinen Zufall gibt und die definitiv in einer endlichen Zahl an Zügen enden, angewendet werden kann, um für beide Spieler eine optimale Strategie herauszufinden und zu untersuchen, welcher Spieler ein Spiel gewinnt \bzw ob es in einem Unentschieden endet\footnote{Conway, J.H. (1983). Objektive Spiele und das Nimm Spiel. In: Über Zahlen und Spiele. \url{https://doi.org/10.1007/978-3-322-88997-3_12} (Abgerufen 14.03.2024)}.


\subsection{Erklärung des Minimax Algorithmus}\label{subsec:erklarung-des-minimax-algorithmus}
Für die Ausführung des Minimax Algorithmus werden zunächst alle möglichen Positionen des zu untersuchenden Spiels als Baum dargestellt, wobei die Knoten dieses Baumes die Spielpositionen darstellen und die Kanten die Züge.
Zusätzlich wird jedem Blatt des Baumes ein numerischer Wert zugeordnet, der angibt, ob diese Endposition gut oder schlecht für den Spieler ist, der den nächsten \bzw den ersten Zug macht.
Traditionell bekommt eine Position, die ein Sieg für den jeweiligen Spieler ist, den Wert $ 1.0 $ zugewiesen, während eine Niederlage symmetrisch den Wert $ -1.0 $ bekommt.
Ein Gleichstand \bzw Unentschieden bekommt den Wert $ 0.0 $.
Im Falle von Spielen, bei denen ein Sieg \bzw eine Niederlage enger numerisch beschrieben werden kann, da die genaue Endpunktzahl für \zB eine Turnierwertung relevant ist, können hierbei auch Endpunkte \undaehnliches verwendet werden, solange diese für einen Sieg des einen Spielers positiv und im Siegesfall des anderen Spielers negativ sind.
Nun ist es das Ziel eines der beiden Spieler diesen Endwert der Spielpositionen zu \textbf{mini}mieren und das Ziel des anderen Spielers diesen zu \textbf{max}imieren.
Aus diesem Fakt leitet sich auch der Name des Algorithmus \enquote{MiniMax} her.
Der Algorithmus geht rekursiv durch diesen Baum, dabei wechselt er auf jeder Ebene zwischen den Zielen der beiden Spieler.
Falls der aktuelle Knoten bereits einen Wert enthält, also ein Blatt des Baumes ist, gibt der Minimax Algorithmus dessen Wert unverändert zurück.
Falls dies nicht der Fall ist, ruft er sich selbst auf allen dem aktuellen Knoten untergeordneten Knoten auf und gibt den Minimal \bzw Maximalwert der Rückgabewerte dieser Aufrufe zurück, je nachdem welche der beiden Strategien gerade angewandt wird\footnote{Roberts, E. \etal (2003): Stratigies and Tactics for Intelligent Seach: Algorithms - Minimax \url{https://cs.stanford.edu/people/eroberts/courses/soco/projects/2003-04/intelligent-search/minimax.html} (Abgerufen 14.03.2024)}.
In meiner Implementierungen dieses Algorithmus~\ref{code} wird diese Baumstruktur nicht erst erstellt, sondern der Algorithmus generiert die nächstmöglichen Züge einer Position während der Ausführung des Algorithmus.
So kann Arbeitsspeicher gespart werden kann, indem vollständige Baum gespeichert werden muss.
Für eine Visualisierung dieses Algorithmus, siehe: Abbildung~\ref{fig:minimax-visulisation}.

\subsection{Probleme bei der Anwendung auf das Schachspiel}\label{subsec:probleme-bei-der-anwendung-auf-das-schachspiel}
Während es auf den ersten Blick scheint, dass der Minimax Algorithmus perfekt für die Anwendung auf das Schachspiel geeignet ist, gibt es doch einige Probleme, die dabei sichtbar werden.

\subsubsection{Endlos lange Spiele}
Nach den traditionellen Schach Regeln\footnote{The Rules of Chess \url{https://www.chess-chivalry.com/en/pages/rules-of-chess} (Abgerufen 14.03.2024)} kann ein Schachspiel theoretisch unendlich lange gespielt werden, da eine unendliche Wiederholung einiger Zugsequenzen möglich ist, \zB die Zugsequenz {\fontfamily{lmss}\selectfont Nc3 Nc6 Nb1 Nb8}, falls diese aus der Startposition gespielt wird.
Moderne Turnierregeln\footnote{FIDE LAWS of CHESS, (2023): \url{https://www.fide.com/FIDE/handbook/LawsOfChess.pdf} (Abgerufen 14.03.2024)} umgehen dieses Problem durch das Einführen von 3 zusätzlichen Endbedingungen des Spiels, die als Unentschieden gewertet werden:
\begin{itemize}
    \item Das Brett befindet sich in einer Position in der kein Spieler mehr Schachmatt setzen kann.
    \item Die selbe Position des Schachbrettes ist im Verlauf des Spiels 3 mal aufgetreten.
    \item Jeder Spieler hat 50 Züge gemacht, in denen kein Bauer bewegt und keine Figur oder Bauer geschlagen wurde.
\end{itemize}
Zwar müssen diese Endbedingungen, damit sie tatsächlich das Spiel beenden, von einem der beiden Spieler explizit ausgerufen werden, da dies aber auch in den Zügen des Algorithmus passieren kann, kann dieser diese Situationen als Unentschieden werten und in diesen das Unentschieden ausrufen.
\subsubsection{Laufzeit des Algorithmus}
Zwar ist es mit diesen Regeländerungen theoretisch möglich den Minimax Algorithmus auf das Schachspiel anzuwenden, allerdings liegt die Anzahl an möglichen Schachspielen bei  über $ 10^{120} $ \footnote{Claude Shannon (1950): Programming a Computer for Playing Chess \url{https://vision.unipv.it/IA1/ProgrammingaComputerforPlayingChess.pdf} (Abgerufen 16.02.2024)} und somit würde der Minimax Algorithmus für eine sehr lange Zeit laufen.
Daher muss der Minimax Algorithmus etwas angepasst werden, um praktikabel auf das Schachspiel angewandt zu werden.
Dazu wird die maximale Suchtiefe des Algorithmus limitiert.
Dadurch ist nicht jeder Knoten, bei dem die Suche endet, ein das Spiel beendender Blattknoten.
Deshalb müssen diesen Knoten nun andere Werte für die Anwendung des Minimax Algorithmus zugewiesen werden.
Dafür kommen \sog Bewertungsfunktionen zum Einsatz, die die gegebenen Brettpositionen bewerten, ohne weitere Züge in der Zukunft zu berücksichtigen\footnotemark[3].

TODO: DEN KOMMENDEN ABSATZ ÜBERDENKEN
\subsection{Optimierung: Alpha Beta Pruning}\label{subsec:optimierung:-alpha-beta-pruning}
Die Laufzeit des Minimax Algorithmus ist schon bei relativ kleiner Rekursionstiefe sehr lang, da es während eines Schachspiels aus jeder Position \ca 35 mögliche Züge\footnote{Laramée, F. D. (2000)  Chess Programming Part IV: Basic Search \url{https://www.gamedev.net/tutorials/_/technical/artificial-intelligence/chess-programming-part-iv-basic-search-r1171/}} gibt und somit die Anzahl an möglichen erreichbaren Positionen mit der Rekursionstiefe stark skaliert.
Die Anzahl an möglichen Positionen, die berücksichtigt werden müssen, lässt sich, ohne das Ergebnis des Algorithmus zu verändern, durch eine Optimierung, die sich \enquote{Alpha Beta Pruning} nennt, deutlich reduzieren.
Dabei werden zusätzlich zu der zu bewertenden Position und zu der gewollten Rekursionstiefe noch zwei weitere Parameter an den Minimax Algorithmus übergeben, die traditionell Alpha und Beta genannt werden.
Diese beiden Parameter geben dem \enquote{Alpha Beta Pruning} seinen Namen.
Beide Werte beschreiben jeweils die minimale Bewertung, die dem maximierenden Spieler zugesichert wird, und die maximale Bewertung, die dem minimierenden Spieler zugesichert wird.
Dadurch können größere Teile des Suchbaumes, für die es unmöglich ist einen Einfluss auf das Ergebnis des Algorithmus zu haben, ignoriert werden \footnote{Russel S. \etal (2020) Artificial Intelligence - A Modern Approach - Fourth Edition}.

\section{Verschiedene Bewertungsfunktionen}\label{sec:verschiedene-bewertungsfunktionen}
Eine gute Bewertungsfunktion zu finden, ist nun die hauptsächliche Möglichkeit das Können des Algorithmus im Schachspiel zu verbessern, daher habe ich mir verschiedene Ansätze für solche Bewertungsfunktionen überlegt, die ich im Folgenden erklären und vergleichen werde.
Allen dieser Bewertungsfunktionen habe ich zu Anfang einige einfache Kontrollen hinzugefügt, die verschiedene Standardfälle überprüfen und dementsprechend bewerten.
Falls der aktuelle Spieler Schachmatt steht, wird ein Wert von $ - \infty $ zurückgegeben und falls der gegnerische Spieler Schachmatt steht, wird ein Wert von $+\infty$ zurückgegeben.
Im Falle eines Patts \bzw bei Erreichen der 50 Züge \bzw einer dreifachen Stellungswiederholung wird der niedrigstmögliche Wert genommen, der nicht $ - \infty$ ist, damit der Algorithmus ein Unentschieden über ein Matt bevorzugt, dieses aber nicht dauerhaft erspielt, wenn er leicht im Nachteil ist.
\subsection{Piece Count}\label{subsec:piece-count}
Einer der ersten Gedanken, auf den man kommen könnte, wenn man versucht eine gegebene Schach Position zu bewerten ist einfach die Anzahl der Figuren beider Seiten zu zählen.
Die Differenz dieser Werte für beide Spieler lässt erkennen, welcher Spieler im Vorteil ist.
\subsection{Piece Value}\label{subsec:piece-value}
Dies ist eine Bewertungsfunktion, die auf der vorherigen aufbaut, allerdings wird jeder Schachfigur nun ein relativer Wert gegeben, anstatt diese gleichwertig zu zählen.
Die Werte die den Figuren traditionell\footnote{José Capablanca \etal (2006): Chess fundamentals : completely revised and updated for the 21st century \url{https://archive.org/details/chessfundamental0000capa/mode/2up} (Abgerufen 17.03.2024)} zugewiesen werden sind wie folgt:
\begin{table}[h!]
    \centering
    \begin{tabular}{||c c ||}
        \hline
        Figur & Wert \\ [0.5ex]
        \hline\hline
        Bauer & 1 \\
        \hline
        Springer & 3 \\
        \hline
        Läufer & 3 \\
        \hline
        Turm & 5 \\
        \hline
        Dame & 9 \\
        \hline
    \end{tabular}
\end{table}\label{tab:Piece Values} \\
Dem König wird hierbei kein Wert zugewiesen, da beide Spieler immer die selbe Anzahl an Königen haben.
\subsection{Attacks}\label{subsec:attacks}
Eine weitere Möglichkeit, die mir eingefallen ist, um die aktuelle Position zu bewerten, ist, zu zählen, wie viele mögliche Angriffe der Spieler in der aktuellen Position hat und welche Figuren diese jeweils angreifen.
Dafür wurden erneut die oben in~\ref{tab:Piece Values} bereits eingesetzen Werte der einzelnen Schachfiguren verwendet.
\subsection{Piece-Square-Tables}\label{subsec:piece-tables}
Ein Ansatz für Bewertungsfunktionen, der von vielen Schach Algorithmen benutzt wird, sind \sog \enquote{Piece-Square-Tables}.
Hierbei wird jeder Figur für jedes der 64 Felder eines Schachbrettes ein Wert zugewiesen, wie \enquote{gerne} diese Figur sich auf diesem Feld befindet.
Dabei können taktische Ideen für die einzelnen Figuren umgesetzt werden\footnote{Good, J. (1968): Machine Intelligence Vol.2 \url{https://www.doc.ic.ac.uk/~shm/MI/mi2.html} (Abgerufen 17.03.2024)}.
Während sich meine tatsächlich verwendeten Piece-Square-Tables sich im Anhang~\ref{fig:piece_square_tables} befinden, erkläre im Folgenden, mit welchen überlegungen ich diese erstellt habe:
\paragraph{Bauer}:
Während die äußeren Bauern hinten bleiben sollen, um den König zu beschützten, sollen die mittleren Bauern  versuchen die Mitte des Schachbrettes einzunehmen, falls diese die Möglichkeit haben, die hintere Kante des Brettes zu erreichen, um sich zu anderen Figuren umzuwandeln
\paragraph{Springer}\label{par:springer}:
 Die Springer sollen von den Kanten des Brettes fernbleiben, um ihre Mobilität hoch zu halten, da \enquote{Springer am Rand bringt Kummer und Schand}\footnote{Bekanntes Zitat unter Schachspielern, herkunft unbekannt \url{https://www.chessbazaar.de/blogs/news/die-superfigur-des-schachspiels-der-springer} (Abgerufen 17.03.2024)}
\paragraph{Läufer}:
Die Läufer werden ähnlich bewertet wie die Springer, da diese auch am Rand weniger effektiv sind, als am Rande des Brettes, da bei diesen der Nachteil am Rand allerdings verglichen mit den~\nameref{par:springer}n klein ist, sind hier die Randwerte etwas größer.
\paragraph{Turm}:
Die Türme sollen zunächst eine kurze \bzw lange Rochade durchführen, zudem sollte sie die Linien $ C $ und $ F $ vermeiden, da diese Häufiger als die anderen von Bauern blockiert werden, alle anderen Linien sind Gleichwertig
\paragraph{Dame}
Der Dame ist durch ihre hohe Mobilität relativ egal, wo sie auf dem Schachbrett steht, allerdings bekommt sie einen Leichten Bonus dafür, wenn sie auf ihrem Startfeld bleibt, zudem bekommt bevorzugt sie das Stehen auf der letzetn Reihe, damit Bauern den Wechsel zu einer Dame bevorzugen.
\paragraph{König}
Der König bleibt vorzugsweise auf den hinteren Feldern in einer der beiden Ecken, besonders den Feldern, auf denen er nach einer Rochade landen würde.
\subsection{Kombinierte Ansätze}\label{subsec:kombinierte-versuche}
Da alle diese Ansätze jeweils nur Teileaspekte eines Guten Schachspiels beleuchten, habe ich die verschiedenen Ansätze für die Bewertungsfunktion wiefolgt zu einer Funktion Kombiniert:
\[
\begin{aligned}
    combined(board) & = & 0.5 & \cdot attacks(board) \\
    & + & 1.0 & \cdot piece\_tables(board) \\
    & + & 10.0 & \cdot piece\_value(board)
\end{aligned}
\]
Hierbei ist die Idee, dass die Mögliche Angriffe nur wenig einfluss auf die Gesamte Bewertung einer Position haben, da viele Mögliche Angriffe zu haben zwar gut ist, aber nicht das wichtigste ist.
Die Piece-Square-Table und Piece Values werden ungefähr gleich bewertet, da die Skalierung dieser beiden Funktionen allerdings verschieden sind werden die Figurwerte mit einem Faktor von $ 10 $ skaliert.

\subsection{Vergleich}\label{subsec:vergleich}
Um nun Tatsächlich herauszufinden, ob diese verschiedenen Bewertungsfunktionen gut oder schlecht sind, müssen diese nun~\nameref{subsubsec:untereinander} und~\nameref{subsubsec:mit menschen} verglichen werden.

\subsubsection{Untereinander}\label{subsubsec:untereinander}
\paragraph{Methodik}
Um die Einzelnen Bewertungsfunktionen miteinander Vergleichen zu können, habe ich ein Turnier zwischen diesen austragen lassen, bei dem der von mir Programmierte Minimax Algorithmus, mit jeder dieser Bewertungsfunktionen ein mal gegen jede andere Bewertungsfunktion gespielt hat.
Dabei wurden jeweils die Unentschieden, Siege und Niederlagen der Verschiedenen Algorithmen gespeichert und daraus dann eine Rangfolge erstellt.
Dabei habe ich jeweils eine Suchtiefe von 6 Halbzügen verwendet.
\paragraph{Ergebnisse}
\emph{TODO: SCHREIBEN NACHDEM FINALES TURNIER DURGELAUFEN IST}
\subsubsection{Mit Menschen}\label{subsubsec:mit menschen}
Beim Spielen mit mehreren Menschen, inklusive mir selbst hat sich leider gezeigt, dass keiner der in dieser Arbeit besprochenen Ansätze besonders erfolgreich darin war gut Schach zu spielen.
Keiner der Algorithmen konnten einen Menschen in einem ernsthaft gespielten Spiel besiegen, da er leider relative Anfängerfehler regelmäßig gemacht hat.
Bei diesen Spielen wurde die Kombinierte Bewertungsfunktion mit einer Suchtiefe von 6 Halbzügen verwendet.
Im folgenden finden sich einige Zitate von Menschen die gegen diesen Bot gespielt haben:

Lucoso: \enquote{Verzeih mir die obszöne Sprache, aber dein Bot ist scheiße}

Pierre Enders: \enquote{Wurde mit 2 Damen in Zug 10 Matt gesetzt}



\section{Fazit}\label{sec:fazit}
Insgesamt hat sich leider gezeigt, dass zumindest mit den Bewertungsfunktionen, die ich mir überlegt habe der Minimax Algorithmus für das Schachspiel nicht sehr gut spielen kann.
Dies liegt vermutlich daran, dass meine Implementierung, die relativ simple und wenig Optimiert ist, dadurch kann ich nur relativ kleine Suchtiefen von $5--6$ Halbzüge erreichen, bevor die Laufzeit des Algorithmus praktisch zu lang wird.
Durch die kleinen Suchtiefe können die verschiedenen Bewertungsfunktionen nicht ihr volles Potential erreichen, da durch eine höhere Suchtiefe die Effekte einzelner Züge über einen deutlich größeren Teil des Spielverlaufes betrachtet werden, während bei einer kleinen Suchtiefe nur die kurzzeitigen Effekte eines Zuges berücksichtigt werden.
\newpage
\section{Schlusserklärung}\label{sec:schlusserklarung}
\emph{
Hiermit erkläre ich, dass ich die vorliegende Arbeit selbstständig und ohne
fremde Hilfe verfasst und keine anderen als die im Literaturverzeichnis
angegebenen Hilfsmittel verwendet habe. Alle genutzten Internetquellen
wurden kenntlich gemacht.
Auch bestätige ich mit meiner Unterschrift, dass ich KI-basierte Dialogsysteme
wie ChatGPT nicht benutzt habe.
Sofern sich – auch zu einem späteren Zeitpunkt – herausstellen sollte, dass die
Arbeit oder Teile davon nicht selbstständig verfasst wurden, die
Zitationshinweise fehlen, Teile aus dem Internet entnommen oder von einer KI
verfasst wurden, so kann die Arbeit auch nachträglich mit null Punkten
gewertet werden.}\footnote{Text der Schlusserklärung vorgegeben durch Lehrkräfte}


\vspace{1cm}

Gelsenkirchen, den \today \\
\begin{center}
    \includegraphics[width=5cm]{./assets/unterschrift}
\end{center}
\newpage

\section{Anhang}\label{sec:anhang}

\begin{figure}[h]
    \centering
    \input{visuazation_listing.txt}
    \caption{Minimax Visualisierung\protect\footnotemark }
    \label{fig:minimax-visulisation}
\end{figure}
\footnotetext{Eigenes Beispiel, Graphiken erstellt mit: \url{https://raphsilva.github.io/utilities/minimax_simulator/}}

    \label{code}
\label{piece_square_tables}

\end{document}